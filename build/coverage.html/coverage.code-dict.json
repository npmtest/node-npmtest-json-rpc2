{"/home/travis/build/npmtest/node-npmtest-json-rpc2/test.js":"/* istanbul instrument in package npmtest_json_rpc2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/lib.npmtest_json_rpc2.js":"/* istanbul instrument in package npmtest_json_rpc2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_json_rpc2 = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_json_rpc2 = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-json-rpc2 && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_json_rpc2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_json_rpc2\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_json_rpc2.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_json_rpc2.rollup.js'] =\n            local.assetsDict['/assets.npmtest_json_rpc2.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_json_rpc2.__dirname + '/lib.npmtest_json_rpc2.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/jsonrpc.js":"'use strict';\n\nexports._ = require('lodash');\nexports.ES5Class = require('es5class');\nexports.Websocket = require('faye-websocket');\nexports.Error = require('./error.js')(exports);\n\nexports.EventEmitter = require('./event-emitter.js')(exports);\n\nexports.Endpoint = require('./endpoint.js')(exports);\nexports.Connection = require('./connection.js')(exports);\n\nexports.HttpServerConnection = require('./http-server-connection.js')(exports);\nexports.SocketConnection = require('./socket-connection.js')(exports);\nexports.WebSocketConnection = require('./websocket-connection.js')(exports);\n\n\nexports.Server = require('./server.js')(exports);\nexports.Client = require('./client.js')(exports);\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/error.js":"module.exports = function (classes){\r\n  'use strict';\r\n\r\n  /*\r\n   JSON-RPC 2.0 Specification Errors codes by dcharbonnier\r\n   */\r\n  var Errors = {};\r\n\r\n  Errors.AbstractError = classes.ES5Class.$define('AbstractError', {\r\n    construct: function(message, extra){\r\n      this.name = this.$className;\r\n      this.extra = extra || {};\r\n      this.message = message || this.$className;\r\n\r\n      Error.captureStackTrace(this, this.$class);\r\n    },\r\n    toString: function(){\r\n      return this.message;\r\n    }\r\n  }).$inherit(Error, []);\r\n\r\n  Errors.ParseError = Errors.AbstractError.$define('ParseError', {\r\n    code: -32700\r\n  });\r\n\r\n  Errors.InvalidRequest = Errors.AbstractError.$define('InvalidRequest', {\r\n    code: -32600\r\n  });\r\n\r\n  Errors.MethodNotFound = Errors.AbstractError.$define('MethodNotFound', {\r\n    code: -32601\r\n  });\r\n\r\n  Errors.InvalidParams = Errors.AbstractError.$define('InvalidParams', {\r\n    code: -32602\r\n  });\r\n\r\n  Errors.InternalError = Errors.AbstractError.$define('InternalError', {\r\n    code: -32603\r\n  });\r\n\r\n  Errors.ServerError = Errors.AbstractError.$define('ServerError', {\r\n    code: -32000\r\n  });\r\n\r\n  return Errors;\r\n};","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/event-emitter.js":"module.exports = function (classes){\n  'use strict';\n\n  var debug = require('debug')('jsonrpc');\n\n  var EventEmitter = classes.ES5Class.$define('EventEmitter', {}, {\n    /**\n     * Output a piece of debug information.\n     */\n    trace : function (direction, message){\n      var msg = '   ' + direction + '   ' + message;\n      debug(msg);\n      return msg;\n    },\n    /**\n     * Check if current request has an id adn it is of type integer (non fractional) or string.\n     *\n     * @param {Object} request\n     * @return {Boolean}\n     */\n    hasId : function (request) {\n      return request && typeof request['id'] !== 'undefined' &&\n      (\n        (typeof(request['id']) === 'number' && /^\\-?\\d+$/.test(request['id'])) ||\n        (typeof(request['id']) === 'string') || (request['id'] === null)\n      );\n    }\n  }).$inherit(require('eventemitter3'), []);\n\n  return EventEmitter;\n};\n\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/endpoint.js":"module.exports = function (classes){\r\n  'use strict';\r\n\r\n  var\r\n    _ = classes._,\r\n    EventEmitter = classes.EventEmitter,\r\n    Error = classes.Error,\r\n    /**\r\n     * Abstract base class for RPC endpoints.\r\n     *\r\n     * Has the ability to register RPC events and expose RPC methods.\r\n     */\r\n      Endpoint = EventEmitter.$define('Endpoint', {\r\n      construct : function ($super){\r\n        $super();\r\n\r\n        this.functions = {};\r\n        this.scopes = {};\r\n        this.defaultScope = this;\r\n        this.exposeModule = this.expose;\r\n      },\r\n      /**\r\n       * Define a callable method on this RPC endpoint\r\n       */\r\n      expose    : function (name, func, scope){\r\n        if (_.isFunction(func)) {\r\n          EventEmitter.trace('***', 'exposing: ' + name);\r\n          this.functions[name] = func;\r\n\r\n          if (scope) {\r\n            this.scopes[name] = scope;\r\n          }\r\n        } else {\r\n          var funcs = [];\r\n\r\n          for (var funcName in func) {\r\n            if (Object.prototype.hasOwnProperty.call(func, funcName)) {\r\n              var funcObj = func[funcName];\r\n              if (_.isFunction(funcObj)) {\r\n                this.functions[name + '.' + funcName] = funcObj;\r\n                funcs.push(funcName);\r\n\r\n                if (scope) {\r\n                  this.scopes[name + '.' + funcName] = scope;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          EventEmitter.trace('***', 'exposing module: ' + name + ' [funs: ' + funcs.join(', ') + ']');\r\n        }\r\n        return func;\r\n      },\r\n      handleCall: function (decoded, conn, callback){\r\n        EventEmitter.trace('<--', 'Request (id ' + decoded.id + '): ' +\r\n          decoded.method + '(' + JSON.stringify(decoded.params) + ')');\r\n\r\n        if (!this.functions.hasOwnProperty(decoded.method)) {\r\n          callback(new Error.MethodNotFound('Unknown RPC call \"' + decoded.method + '\"'));\r\n          return;\r\n        }\r\n\r\n        var method = this.functions[decoded.method];\r\n        var scope = this.scopes[decoded.method] || this.defaultScope;\r\n\r\n        // Try to call the method, but intercept errors and call our\r\n        // error handler.\r\n        try {\r\n          method.call(scope, decoded.params, conn, callback);\r\n        } catch (err) {\r\n          callback(err);\r\n        }\r\n      }\r\n    });\r\n\r\n  return Endpoint;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/connection.js":"module.exports = function (classes){\r\n  'use strict';\r\n\r\n  var\r\n    _ = classes._,\r\n    EventEmitter = classes.EventEmitter,\r\n    Connection = EventEmitter.$define('Connection', {\r\n      construct: function ($super, ep){\r\n        $super();\r\n\r\n        this.endpoint = ep;\r\n        this.callbacks = {};\r\n        this.latestId = 0;\r\n\r\n        // Default error handler (prevents ''uncaught error event'')\r\n        this.on('error', function (){ });\r\n      },\r\n      /**\r\n       * Make a standard RPC call to the other endpoint.\r\n       *\r\n       * Note that some ways to make RPC calls bypass this method, for example HTTP\r\n       * calls and responses are done in other places.\r\n       */\r\n      call     : function (method, params, callback){\r\n        if (!_.isArray(params)) {\r\n          params = [params];\r\n        }\r\n\r\n        var id = null;\r\n        if (_.isFunction(callback)) {\r\n          id = ++this.latestId;\r\n          this.callbacks[id] = callback;\r\n        }\r\n\r\n        EventEmitter.trace('-->', 'Connection call (method ' + method + '): ' + JSON.stringify(params));\r\n\r\n        var data = JSON.stringify({\r\n          jsonrpc: '2.0',\r\n          method : method,\r\n          params : params,\r\n          id     : id\r\n        });\r\n        this.write(data);\r\n      },\r\n\r\n      /**\r\n       * Dummy method for sending data.\r\n       *\r\n       * Connection types that support sending additional data will override this\r\n       * method.\r\n       */\r\n      write: function (){\r\n        throw new Error('Tried to write data on unsupported connection type.');\r\n      },\r\n\r\n      /**\r\n       * Keep the connection open.\r\n       *\r\n       * This method is used to tell a HttpServerConnection to stay open. In order\r\n       * to keep it compatible with other connection types, we add it here and make\r\n       * it register a connection end handler.\r\n       */\r\n      stream: function (onend){\r\n        if (_.isFunction(onend)) {\r\n          this.on('end', function(){\r\n            onend();\r\n          });\r\n        }\r\n      },\r\n\r\n      handleMessage: function (msg){\r\n        var self = this;\r\n\r\n        if (msg) {\r\n          if (\r\n              (msg.hasOwnProperty('result') || msg.hasOwnProperty('error')) &&\r\n              msg.hasOwnProperty('id')\r\n            ) {\r\n            // Are we in the client?\r\n            try {\r\n              this.callbacks[msg.id](msg.error, msg.result);\r\n              delete this.callbacks[msg.id];\r\n            } catch (err) {\r\n              EventEmitter.trace('<---', 'Callback not found ' + msg.id + ': ' + (err.stack ? err.stack : err.toString()));\r\n            }\r\n          } else if (msg.hasOwnProperty('method')) {\r\n            // Are we in the server?\r\n            this.endpoint.handleCall(msg, this, function handleCall(err, result){\r\n              if (err) {\r\n                self.emit('error', err);\r\n\r\n                EventEmitter.trace('-->',\r\n                  'Failure ' + (EventEmitter.hasId(msg) ? '(id ' + msg.id + ')' : '') + ': ' +\r\n                    (err.stack ? err.stack : err.toString())\r\n                );\r\n              }\r\n\r\n              // Return if it's just a notification (no id)\r\n              if (!EventEmitter.hasId(msg)) {\r\n                return;\r\n              }\r\n\r\n              if (err) {\r\n                err = err.toString();\r\n                result = null;\r\n              } else {\r\n                EventEmitter.trace('-->', 'Response (id ' + msg.id + '): ' +\r\n                  JSON.stringify(result));\r\n                err = null;\r\n              }\r\n\r\n              self.sendReply(err, result, msg.id);\r\n            });\r\n          }\r\n        }\r\n      },\r\n\r\n      sendReply: function (err, result, id){\r\n        var data = JSON.stringify({\r\n          jsonrpc: '2.0',\r\n          result : result,\r\n          error  : err,\r\n          id     : id\r\n        });\r\n\r\n        this.write(data);\r\n      }\r\n    });\r\n\r\n  return Connection;\r\n};","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/http-server-connection.js":"module.exports = function (classes){\r\n  'use strict';\r\n\r\n  var\r\n    Connection = classes.Connection,\r\n    HttpServerConnection = Connection.$define('HttpServerConnection', {\r\n    construct: function ($super, server, req, res){\r\n      var self = this;\r\n\r\n      $super(server);\r\n\r\n      this.req = req;\r\n      this.res = res;\r\n      this.isStreaming = false;\r\n\r\n      this.res.on('finish', function responseEnd(){\r\n        self.emit('end');\r\n      });\r\n\r\n      this.res.on('close', function responseEnd(){\r\n        self.emit('end');\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Can be called before the response callback to keep the connection open.\r\n     */\r\n    stream: function ($super, onend){\r\n      $super(onend);\r\n\r\n      this.isStreaming = true;\r\n    },\r\n\r\n    /**\r\n     * Send the client additional data.\r\n     *\r\n     * An HTTP connection can be kept open and additional RPC calls sent through if\r\n     * the client supports it.\r\n     */\r\n    write: function (data){\r\n      if (!this.isStreaming) {\r\n        throw new Error('Cannot send extra messages via non - streaming HTTP');\r\n      }\r\n\r\n      if (!this.res.connection.writable) {\r\n        // Client disconnected, we'll quietly fail\r\n        return;\r\n      }\r\n\r\n      this.res.write(data);\r\n    }\r\n  });\r\n\r\n  return HttpServerConnection;\r\n};","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/socket-connection.js":"module.exports = function (classes){\r\n  'use strict';\r\n\r\n  var\r\n    Connection = classes.Connection,\r\n\r\n    /**\r\n     * Socket connection.\r\n     *\r\n     * Socket connections are mostly symmetric, so we are using a single class for\r\n     * representing both the server and client perspective.\r\n     */\r\n      SocketConnection = Connection.$define('SocketConnection', {\r\n      construct: function ($super, endpoint, conn){\r\n        var self = this;\r\n\r\n        $super(endpoint);\r\n\r\n        self.conn = conn;\r\n        self.autoReconnect = true;\r\n        self.ended = true;\r\n\r\n        self.conn.on('connect', function socketConnect(){\r\n          self.emit('connect');\r\n        });\r\n\r\n        self.conn.on('end', function socketEnd(){\r\n          self.emit('end');\r\n        });\r\n\r\n        self.conn.on('error', function socketError(event){\r\n          self.emit('error', event);\r\n        });\r\n\r\n        self.conn.on('close', function socketClose(hadError){\r\n          self.emit('close', hadError);\r\n\r\n          if (\r\n            self.endpoint.$className === 'Client' &&\r\n              self.autoReconnect && !self.ended\r\n            ) {\r\n            if (hadError) {\r\n              // If there was an error, we'll wait a moment before retrying\r\n              setTimeout(function reconnectTimeout(){\r\n                self.reconnect();\r\n              }, 200);\r\n            } else {\r\n              self.reconnect();\r\n            }\r\n          }\r\n        });\r\n      },\r\n      write    : function (data){\r\n        if (!this.conn.writable) {\r\n          // Other side disconnected, we'll quietly fail\r\n          return;\r\n        }\r\n\r\n        this.conn.write(data);\r\n      },\r\n\r\n      end: function (){\r\n        this.ended = true;\r\n        this.conn.end();\r\n      },\r\n\r\n      reconnect: function (){\r\n        this.ended = false;\r\n        if (this.endpoint.$className === 'Client') {\r\n          this.conn.connect(this.endpoint.port, this.endpoint.host);\r\n        } else {\r\n          throw new Error('Cannot reconnect a connection from the server-side.');\r\n        }\r\n      }\r\n    });\r\n\r\n  return SocketConnection;\r\n};","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/websocket-connection.js":"module.exports = function (classes){\n  'use strict';\n\n  var\n    Connection = classes.Connection,\n\n    /**\n     * Websocket connection.\n     *\n     * Socket connections are mostly symmetric, so we are using a single class for\n     * representing both the server and client perspective.\n     */\n      WebSocketConnection = Connection.$define('WebSocketConnection', {\n      construct: function ($super, endpoint, conn){\n        var self = this;\n\n        $super(endpoint);\n\n        self.conn = conn;\n        self.ended = false;\n\n        self.conn.on('close', function websocketClose(hadError){\n          self.emit('close', hadError);\n        });\n      },\n      write: function(data){\n        if (!this.conn.writable) {\n          // Other side disconnected, we'll quietly fail\n          return;\n        }\n\n        this.conn.write(data);\n      },\n      end: function(){\n        this.conn.close();\n        this.ended = true;\n      }\n    });\n\n  return WebSocketConnection;\n};","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/server.js":"module.exports = function (classes) {\n  'use strict';\n\n  var\n    net = require('net'),\n    http = require('http'),\n    extend = require('object-assign'),\n    JsonParser = require('jsonparse'),\n\n    UNAUTHORIZED = 'Unauthorized',\n    METHOD_NOT_ALLOWED = 'Invalid Request',\n    INVALID_REQUEST = 'Invalid Request',\n    _ = classes._,\n    Endpoint = classes.Endpoint,\n    WebSocket = classes.Websocket,\n    Error = classes.Error,\n\n    /**\n     * JSON-RPC Server.\n     */\n      Server = Endpoint.$define('Server', {\n      construct: function ($super, opts) {\n        $super();\n\n        this.opts = opts || {};\n        this.opts.type = typeof this.opts.type !== 'undefined' ? this.opts.type : 'http';\n        this.opts.headers = this.opts.headers || {};\n        this.opts.websocket = typeof this.opts.websocket !== 'undefined' ? this.opts.websocket : true;\n      },\n      _checkAuth: function (req, res) {\n        var self = this;\n\n        if (self.authHandler) {\n          var\n            authHeader = req.headers['authorization'] || '', // get the header\n            authToken = authHeader.split(/\\s+/).pop() || '', // get the token\n            auth = new Buffer(authToken, 'base64').toString(), // base64 -> string\n            parts = auth.split(/:/), // split on colon\n            username = parts[0],\n            password = parts[1];\n\n          if (!this.authHandler(username, password)) {\n            if (res) {\n              classes.EventEmitter.trace('<--', 'Unauthorized request');\n              Server.handleHttpError(req, res, new Error.InvalidParams(UNAUTHORIZED), self.opts.headers);\n            }\n            return false;\n          }\n        }\n        return true;\n      },\n      /**\n       * Start listening to incoming connections.\n       */\n      listen: function (port, host) {\n        var\n          self = this,\n          server = http.createServer();\n\n        server.on('request', function onRequest(req, res) {\n          self.handleHttp(req, res);\n        });\n\n        if (port) {\n          server.listen(port, host);\n          Endpoint.trace('***', 'Server listening on http://' +\n            (host || '127.0.0.1') + ':' + port + '/');\n        }\n\n        if (this.opts.websocket === true) {\n          server.on('upgrade', function onUpgrade(req, socket, body) {\n            if (WebSocket.isWebSocket(req)) {\n              if (self._checkAuth(req, socket)) {\n                self.handleWebsocket(req, socket, body);\n              }\n            }\n          });\n        }\n\n        return server;\n      },\n\n      listenRaw: function (port, host) {\n        var\n          self = this,\n          server = net.createServer(function createServer(socket) {\n            self.handleRaw(socket);\n          });\n\n        server.listen(port, host);\n\n        Endpoint.trace('***', 'Server listening on tcp://' +\n          (host || '127.0.0.1') + ':' + port + '/');\n\n        return server;\n      },\n\n      listenHybrid: function (port, host) {\n        var\n          self = this,\n          httpServer = self.listen(),\n          server = net.createServer(function createServer(socket) {\n            self.handleHybrid(httpServer, socket);\n          });\n\n        server.listen(port, host);\n\n        Endpoint.trace('***', 'Server (hybrid) listening on http+tcp://' +\n          (host || '127.0.0.1') + ':' + port + '/');\n\n        return server;\n      },\n\n      /**\n       * Handle HTTP POST request.\n       */\n      handleHttp: function (req, res) {\n        var buffer = '', self = this;\n        var headers;\n\n        if (req.method === 'OPTIONS') {\n          headers = {\n            'Content-Length': 0,\n            'Access-Control-Allow-Headers': 'Accept, Authorization, Content-Type'\n          };\n          headers = extend({}, headers, self.opts.headers);\n          res.writeHead(200, headers);\n          res.end();\n          return;\n        }\n\n        if (!self._checkAuth(req, res)) {\n          return;\n        }\n\n        Endpoint.trace('<--', 'Accepted http request');\n\n        if (req.method !== 'POST') {\n          Server.handleHttpError(req, res, new Error.InvalidRequest(METHOD_NOT_ALLOWED), self.opts.headers);\n          return;\n        }\n\n        var handle = function handle(buf) {\n          // Check if json is valid JSON document\n          var decoded;\n\n          try {\n            decoded = JSON.parse(buf);\n          } catch (error) {\n            Server.handleHttpError(req, res, new Error.ParseError(INVALID_REQUEST), self.opts.headers);\n            return;\n          }\n\n          // Check for the required fields, and if they aren't there, then\n          // dispatch to the handleHttpError function.\n          if (!decoded.method || !decoded.params) {\n            Endpoint.trace('-->', 'Response (invalid request)');\n            Server.handleHttpError(req, res, new Error.InvalidRequest(INVALID_REQUEST), self.opts.headers);\n            return;\n          }\n\n          var reply = function reply(json) {\n            var encoded;\n            headers = {\n              'Content-Type': 'application/json'\n            };\n\n            if (json) {\n              encoded = JSON.stringify(json);\n              headers['Content-Length'] = Buffer.byteLength(encoded, 'utf-8');\n            } else {\n              encoded = '';\n              headers['Content-Length'] = 0;\n            }\n\n            headers = extend({}, headers, self.opts.headers);\n\n            if (!conn.isStreaming) {\n              res.writeHead(200, headers);\n              res.write(encoded);\n              res.end();\n            } else {\n              res.writeHead(200, headers);\n              res.write(encoded);\n              // Keep connection open\n            }\n          };\n\n          var callback = function callback(err, result) {\n            var response;\n            if (err) {\n\n              self.emit('error', err);\n\n              Endpoint.trace('-->', 'Failure (id ' + decoded.id + '): ' +\n                (err.stack ? err.stack : err.toString()));\n\n              result = null;\n\n              if (!(err instanceof Error.AbstractError)) {\n                err = new Error.InternalError(err.toString());\n              }\n\n              response = {\n                'jsonrpc': '2.0',\n                'error': {code: err.code, message: err.message }\n              };\n\n            } else {\n              Endpoint.trace('-->', 'Response (id ' + decoded.id + '): ' +\n                JSON.stringify(result));\n\n              response = {\n                'jsonrpc': '2.0',\n                'result': typeof(result) === 'undefined' ? null : result\n              };\n            }\n\n            // Don't return a message if it doesn't have an ID\n            if (Endpoint.hasId(decoded)) {\n              response.id = decoded.id;\n              reply(response);\n            } else {\n              reply();\n            }\n          };\n\n          var conn = new classes.HttpServerConnection(self, req, res);\n\n          self.handleCall(decoded, conn, callback);\n        }; // function handle(buf)\n\n        req.on('data', function requestData(chunk) {\n          buffer = buffer + chunk;\n        });\n\n        req.on('end', function requestEnd() {\n          handle(buffer);\n        });\n      },\n\n      handleRaw: function (socket) {\n        var self = this, conn, parser, requireAuth;\n\n        Endpoint.trace('<--', 'Accepted socket connection');\n\n        conn = new classes.SocketConnection(self, socket);\n        parser = new JsonParser();\n        requireAuth = !!this.authHandler;\n\n        parser.onValue = function (decoded) {\n          if (this.stack.length) {\n            return;\n          }\n\n          // We're on a raw TCP socket. To enable authentication we implement a simple\n          // authentication scheme that is non-standard, but is easy to call from any\n          // client library.\n          //\n          // The authentication message is to be sent as follows:\n          //   {'method': 'auth', 'params': ['myuser', 'mypass'], id: 0}\n          if (requireAuth) {\n            if (decoded.method !== 'auth') {\n              // Try to notify client about failure to authenticate\n              if (Endpoint.hasId(decoded)) {\n                conn.sendReply('Error: Unauthorized', null, decoded.id);\n              }\n            } else {\n              // Handle 'auth' message\n              if (_.isArray(decoded.params) &&\n                decoded.params.length === 2 &&\n                self.authHandler(decoded.params[0], decoded.params[1])) {\n                // Authorization completed\n                requireAuth = false;\n\n                // Notify client about success\n                if (Endpoint.hasId(decoded)) {\n                  conn.sendReply(null, true, decoded.id);\n                }\n              } else {\n                if (Endpoint.hasId(decoded)) {\n                  conn.sendReply('Error: Invalid credentials', null, decoded.id);\n                }\n              }\n            }\n            // Make sure we explicitly return here - the client was not yet auth'd.\n            return;\n          } else {\n            conn.handleMessage(decoded);\n          }\n        };\n\n        socket.on('data', function (chunk) {\n          try {\n            parser.write(chunk);\n          } catch (err) {\n            // TODO: Is ignoring invalid data the right thing to do?\n          }\n        });\n      },\n\n      handleWebsocket: function (request, socket, body) {\n        var self = this, conn, parser;\n\n        socket = new WebSocket(request, socket, body);\n\n        Endpoint.trace('<--', 'Accepted Websocket connection');\n\n        conn = new classes.WebSocketConnection(self, socket);\n        parser = new JsonParser();\n\n        parser.onValue = function (decoded) {\n          if (this.stack.length) {\n            return;\n          }\n\n          conn.handleMessage(decoded);\n        };\n\n        socket.on('message', function (event) {\n          try {\n            parser.write(event.data);\n          } catch (err) {\n            // TODO: Is ignoring invalid data the right thing to do?\n          }\n        });\n      },\n\n      handleHybrid: function (httpServer, socket) {\n        var self = this;\n\n        socket.once('data', function (chunk) {\n          // If first byte is a capital letter, treat connection as HTTP\n          if (chunk[0] >= 65 && chunk[0] <= 90) {\n            // TODO: need to find a better way to do this\n            http._connectionListener.call(httpServer, socket);\n            socket.ondata(chunk, 0, chunk.length);\n          } else {\n            self.handleRaw(socket);\n            // Re-emit first chunk\n            socket.emit('data', chunk);\n          }\n        });\n      },\n\n      /**\n       * Set the server to require authentication.\n       *\n       * Can be called with a custom handler function:\n       *   server.enableAuth(function (user, password) {\n       *     return true; // Do authentication and return result as boolean\n       *   });\n       *\n       * Or just with a single valid username and password:\n       *   sever.enableAuth(''myuser'', ''supersecretpassword'');\n       */\n      enableAuth: function (handler, password) {\n        if (!_.isFunction(handler)) {\n          var user = '' + handler;\n          password = '' + password;\n\n          handler = function checkAuth(suppliedUser, suppliedPassword) {\n            return user === suppliedUser && password === suppliedPassword;\n          };\n        }\n\n        this.authHandler = handler;\n      }\n    }, {\n      /**\n       * Handle a low level server error.\n       */\n      handleHttpError: function (req, res, error, custom_headers) {\n        var message = JSON.stringify({\n          'jsonrpc': '2.0',\n          'error': {code: error.code, message: error.message},\n          'id': null\n        });\n        custom_headers = custom_headers || {};\n        var headers = extend({\n            'Content-Type': 'application/json',\n            'Content-Length': Buffer.byteLength(message),\n            'Access-Control-Allow-Headers': 'Content-Type',\n            'Allow': 'POST'\n        }, custom_headers);\n\n        /*if (code === 401) {\n         headers['WWW-Authenticate'] = 'Basic realm=' + 'JSON-RPC' + '';\n         }*/\n\n        if (res.writeHead) {\n          res.writeHead(200, headers);\n          res.write(message);\n        } else {\n          headers['Content-Length'] += 3;\n          res.write(headers + '\\n\\n' + message + '\\n');\n        }\n        res.end();\n      }\n    });\n\n  return Server;\n};\n","/home/travis/build/npmtest/node-npmtest-json-rpc2/node_modules/json-rpc2/src/client.js":"module.exports = function (classes){\r\n  'use strict';\r\n\r\n  var\r\n    net = require('net'),\r\n    http = require('http'),\r\n    https = require('https'),\r\n    WebSocket = classes.Websocket,\r\n    JsonParser = require('jsonparse'),\r\n    EventEmitter = classes.EventEmitter,\r\n    Endpoint = classes.Endpoint,\r\n    _ = classes._,\r\n    SocketConnection = classes.SocketConnection,\r\n    WebSocketConnection = classes.WebSocketConnection,\r\n    /**\r\n     * JSON-RPC Client.\r\n     */\r\n      Client = Endpoint.$define('Client', {\r\n      construct    : function ($super, port, host, user, password){\r\n        $super();\r\n\r\n        this.port = port;\r\n        this.host = host;\r\n        this.user = user;\r\n        this.password = password;\r\n      },\r\n      _authHeader: function(headers){\r\n        if (this.user && this.password) {\r\n          var buff = new Buffer(this.user + ':' + this.password).toString('base64');\r\n          headers['Authorization'] = 'Basic ' + buff;\r\n        }\r\n      },\r\n      /**\r\n       * Make HTTP connection/request.\r\n       *\r\n       * In HTTP mode, we get to submit exactly one message and receive up to n\r\n       * messages.\r\n       */\r\n      connectHttp  : function (method, params, opts, callback){\r\n        if (_.isFunction(opts)) {\r\n          callback = opts;\r\n          opts = {};\r\n        }\r\n        opts = opts || {};\r\n\r\n        var id = 1, self = this;\r\n\r\n        // First we encode the request into JSON\r\n        var requestJSON = JSON.stringify({\r\n          'id'     : id,\r\n          'method' : method,\r\n          'params' : params,\r\n          'jsonrpc': '2.0'\r\n        });\r\n\r\n        var headers = {};\r\n\r\n        this._authHeader(headers);\r\n\r\n        // Then we build some basic headers.\r\n        headers['Host'] = this.host;\r\n        headers['Content-Length'] = Buffer.byteLength(requestJSON, 'utf8');\r\n\r\n        // Now we'll make a request to the server\r\n        var options = {\r\n          hostname: this.host,\r\n          port    : this.port,\r\n          path    : opts.path || '/',\r\n          method  : 'POST',\r\n          headers : headers\r\n        };\r\n        var request;\r\n        if(opts.https === true) {\r\n          if(opts.rejectUnauthorized !== undefined) {\r\n            options.rejectUnauthorized = opts.rejectUnauthorized;\r\n          }\r\n          request = https.request(options);\r\n        } else {\r\n          request = http.request(options);\r\n        }\r\n\r\n\r\n        // Report errors from the http client. This also prevents crashes since\r\n        // an exception is thrown if we don't handle this event.\r\n        request.on('error', function requestError(err){\r\n          callback(err);\r\n        });\r\n        request.write(requestJSON);\r\n        request.on('response', function requestResponse(response){\r\n          callback.call(self, id, request, response);\r\n        });\r\n      },\r\n      connectWebsocket: function(callback){\r\n        var self = this, conn, socket, parser, headers = {};\r\n\r\n        if (!/^wss?:\\/\\//i.test(self.host)) {\r\n          self.host = 'ws://' + self.host + ':' + self.port + '/';\r\n        }\r\n\r\n        this._authHeader(headers);\r\n\r\n        socket = new WebSocket.Client(self.host, null, {headers: headers});\r\n\r\n        conn = new WebSocketConnection(self, socket);\r\n\r\n        parser = new JsonParser();\r\n\r\n        parser.onValue = function parseOnValue(decoded){\r\n          if (this.stack.length) {\r\n            return;\r\n          }\r\n\r\n          conn.handleMessage(decoded);\r\n        };\r\n\r\n        socket.on('error', function socketError(event){\r\n          callback(event.reason);\r\n        });\r\n\r\n        socket.on('open', function socketOpen(){\r\n          callback(null, conn);\r\n        });\r\n\r\n        socket.on('message', function socketMessage(event){\r\n          try {\r\n            parser.write(event.data);\r\n          } catch (err) {\r\n            EventEmitter.trace('<--', err.toString());\r\n          }\r\n        });\r\n\r\n        return conn;\r\n      },\r\n      /**\r\n       * Make Socket connection.\r\n       *\r\n       * This implements JSON-RPC over a raw socket. This mode allows us to send and\r\n       * receive as many messages as we like once the socket is established.\r\n       */\r\n      connectSocket: function (callback){\r\n        var self = this, socket, conn, parser;\r\n\r\n        socket = net.connect(this.port, this.host, function netConnect(){\r\n          // Submit non-standard 'auth' message for raw sockets.\r\n          if (!_.isEmpty(self.user) && !_.isEmpty(self.password)) {\r\n            conn.call('auth', [self.user, self.password], function connectionAuth(err){\r\n              if (err) {\r\n                callback(err);\r\n              } else {\r\n                callback(null, conn);\r\n              }\r\n            });\r\n            return;\r\n          }\r\n\r\n          if (_.isFunction(callback)) {\r\n            callback(null, conn);\r\n          }\r\n        });\r\n\r\n        conn = new SocketConnection(self, socket);\r\n        parser = new JsonParser();\r\n\r\n        parser.onValue = function parseOnValue(decoded){\r\n          if (this.stack.length) {\r\n            return;\r\n          }\r\n\r\n          conn.handleMessage(decoded);\r\n        };\r\n\r\n        socket.on('data', function socketData(chunk){\r\n          try {\r\n            parser.write(chunk);\r\n          } catch (err) {\r\n            EventEmitter.trace('<--', err.toString());\r\n          }\r\n        });\r\n\r\n        return conn;\r\n      },\r\n      stream       : function (method, params, opts, callback){\r\n        if (_.isFunction(opts)) {\r\n          callback = opts;\r\n          opts = {};\r\n        }\r\n        opts = opts || {};\r\n\r\n        this.connectHttp(method, params, opts, function connectHttp(id, request, response){\r\n          if (_.isFunction(callback)) {\r\n            var connection = new EventEmitter();\r\n\r\n            connection.id = id;\r\n            connection.req = request;\r\n            connection.res = response;\r\n\r\n            connection.expose = function connectionExpose(method, callback){\r\n              connection.on('call:' + method, function connectionCall(data){\r\n                callback.call(null, data.params || []);\r\n              });\r\n            };\r\n\r\n            connection.end = function connectionEnd(){\r\n              this.req.connection.end();\r\n            };\r\n\r\n            // We need to buffer the response chunks in a nonblocking way.\r\n            var parser = new JsonParser();\r\n            parser.onValue = function (decoded){\r\n              if (this.stack.length) {\r\n                return;\r\n              }\r\n\r\n              connection.emit('data', decoded);\r\n              if (\r\n                decoded.hasOwnProperty('result') ||\r\n                  decoded.hasOwnProperty('error') &&\r\n                    decoded.id === id && _.isFunction(callback)\r\n                ) {\r\n                connection.emit('result', decoded);\r\n              }\r\n              else if (decoded.hasOwnProperty('method')) {\r\n                connection.emit('call:' + decoded.method, decoded);\r\n              }\r\n            };\r\n\r\n            if (response) {\r\n              // Handle headers\r\n              connection.res.once('data', function connectionOnce(data){\r\n                if (connection.res.statusCode === 200) {\r\n                  callback(null, connection);\r\n                } else {\r\n                  callback(new Error('\"' + connection.res.statusCode + '\"' + data));\r\n                }\r\n              });\r\n\r\n              connection.res.on('data', function connectionData(chunk){\r\n                try {\r\n                  parser.write(chunk);\r\n                } catch (err) {\r\n                  // TODO: Is ignoring invalid data the right thing to do?\r\n                }\r\n              });\r\n\r\n              connection.res.on('end', function connectionEnd(){\r\n                // TODO: Issue an error if there has been no valid response message\r\n              });\r\n            }\r\n          }\r\n        });\r\n      },\r\n      call         : function (method, params, opts, callback){\r\n        if (_.isFunction(opts)) {\r\n          callback = opts;\r\n          opts = {};\r\n        }\r\n        opts = opts || {};\r\n        EventEmitter.trace('-->', 'Http call (method ' + method + '): ' + JSON.stringify(params));\r\n\r\n        this.connectHttp(method, params, opts, function connectHttp(id, request, response){\r\n          // Check if response object exists.\r\n          if (!response) {\r\n            callback(new Error('Have no response object'));\r\n            return;\r\n          }\r\n\r\n          var data = '';\r\n\r\n          response.on('data', function responseData(chunk){\r\n            data += chunk;\r\n          });\r\n\r\n          response.on('end', function responseEnd(){\r\n            if (response.statusCode !== 200) {\r\n              callback(new Error('\"' + response.statusCode + '\"' + data))\r\n              ;\r\n              return;\r\n            }\r\n            var decoded = JSON.parse(data);\r\n            if (_.isFunction(callback)) {\r\n              if (!decoded.error) {\r\n                decoded.error = null;\r\n              }\r\n              callback(decoded.error, decoded.result);\r\n            }\r\n          });\r\n        });\r\n      }\r\n    });\r\n\r\n  return Client;\r\n};\r\n"}